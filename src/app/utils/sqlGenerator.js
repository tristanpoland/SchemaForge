// utils/sqlGenerator.js

export const generateSql = (schema, edges, nodes) => {
  let sql = '-- Generated by SchemaForge\n';
  sql += '-- Professional SQL Database Designer\n';
  sql += `-- Generated on: ${new Date().toISOString()}\n\n`;
  
  // Generate CREATE TABLE statements
  Object.entries(schema).forEach(([nodeId, table]) => {
    if (!table.tableName || !table.fields || table.fields.length === 0) return;
    
    sql += `-- Table: ${table.tableName}\n`;
    sql += `CREATE TABLE ${table.tableName} (\n`;
    
    const fieldDefinitions = table.fields.map(field => {
      let def = `    ${field.name} ${field.type}`;
      
      // Add length/precision for applicable types
      if (field.length) {
        def += `(${field.length})`;
      } else if (field.type === 'VARCHAR' && !field.length) {
        def += '(255)'; // Default VARCHAR length
      }
      
      // Add constraints
      if (!field.nullable) {
        def += ' NOT NULL';
      }
      
      if (field.unique && !field.primaryKey) {
        def += ' UNIQUE';
      }
      
      if (field.autoIncrement) {
        def += ' AUTO_INCREMENT';
      }
      
      if (field.defaultValue && field.defaultValue.trim() !== '') {
        // Handle different default value types
        if (field.type === 'TIMESTAMP' && field.defaultValue.toUpperCase() === 'CURRENT_TIMESTAMP') {
          def += ' DEFAULT CURRENT_TIMESTAMP';
        } else if (['INT', 'BIGINT', 'DECIMAL', 'FLOAT', 'DOUBLE', 'TINYINT', 'SMALLINT', 'MEDIUMINT'].includes(field.type)) {
          def += ` DEFAULT ${field.defaultValue}`;
        } else {
          def += ` DEFAULT '${field.defaultValue}'`;
        }
      }
      
      return def;
    });
    
    sql += fieldDefinitions.join(',\n');
    
    // Add primary key constraint
    const primaryKeys = table.fields.filter(f => f.primaryKey);
    if (primaryKeys.length > 0) {
      sql += `,\n    PRIMARY KEY (${primaryKeys.map(f => f.name).join(', ')})`;
    }
    
    // Add unique constraints for non-primary unique fields
    const uniqueFields = table.fields.filter(f => f.unique && !f.primaryKey);
    uniqueFields.forEach(field => {
      sql += `,\n    UNIQUE KEY uk_${table.tableName}_${field.name} (${field.name})`;
    });
    
    sql += '\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n';
  });
  
  // Generate foreign key constraints based on actual schema relationships
  let foreignKeyConstraints = [];
  
  // Process foreign keys from field definitions in schema
  Object.entries(schema).forEach(([nodeId, table]) => {
    if (!table.fields) return;
    
    table.fields.forEach(field => {
      if (field.foreignKey && field.referencedTable && field.referencedField) {
        // Find the referenced table and field details
        const referencedTableNode = nodes.find(n => n.id === field.referencedTable);
        const referencedTableData = schema[field.referencedTable];
        
        if (referencedTableData) {
          const referencedField = referencedTableData.fields.find(f => f.id.toString() === field.referencedField.toString());
          
          if (referencedField) {
            const constraintName = `fk_${table.tableName}_${field.name}`;
            
            // Avoid duplicates
            if (!foreignKeyConstraints.some(fk => 
              fk.sourceTable === table.tableName && 
              fk.sourceField === field.name
            )) {
              foreignKeyConstraints.push({
                sourceTable: table.tableName,
                sourceField: field.name,
                targetTable: referencedTableData.tableName,
                targetField: referencedField.name,
                constraintName,
                sourceFieldType: field.type,
                targetFieldType: referencedField.type
              });
            }
          }
        }
      }
    });
  });
  
  // Process additional foreign keys from visual connections (edges)
  edges.forEach(edge => {
    if (edge.data?.foreignKey) {
      const sourceTable = schema[edge.source];
      const targetTable = schema[edge.target];
      
      if (sourceTable && targetTable && edge.data.sourceField && edge.data.targetField) {
        const sourceField = sourceTable.fields.find(f => f.id.toString() === edge.data.sourceField.toString());
        const targetField = targetTable.fields.find(f => f.id.toString() === edge.data.targetField.toString());
        
        if (sourceField && targetField) {
          const constraintName = `fk_${sourceTable.tableName}_${sourceField.name}`;
          
          // Avoid duplicates
          if (!foreignKeyConstraints.some(fk => 
            fk.sourceTable === sourceTable.tableName && 
            fk.sourceField === sourceField.name &&
            fk.targetTable === targetTable.tableName &&
            fk.targetField === targetField.name
          )) {
            foreignKeyConstraints.push({
              sourceTable: sourceTable.tableName,
              sourceField: sourceField.name,
              targetTable: targetTable.tableName,
              targetField: targetField.name,
              constraintName,
              sourceFieldType: sourceField.type,
              targetFieldType: targetField.type
            });
          }
        }
      }
    }
  });
  
  // Add foreign key constraints
  if (foreignKeyConstraints.length > 0) {
    sql += '-- Foreign Key Constraints\n';
    sql += '-- Ensures referential integrity between related tables\n\n';
    
    foreignKeyConstraints.forEach(fk => {
      sql += `-- ${fk.sourceTable}.${fk.sourceField} -> ${fk.targetTable}.${fk.targetField}\n`;
      sql += `ALTER TABLE ${fk.sourceTable} ADD CONSTRAINT ${fk.constraintName}\n`;
      sql += `    FOREIGN KEY (${fk.sourceField}) REFERENCES ${fk.targetTable}(${fk.targetField})\n`;
      sql += `    ON DELETE RESTRICT ON UPDATE CASCADE;\n\n`;
    });
  }
  
  // Add indexes for foreign keys (performance optimization)
  if (foreignKeyConstraints.length > 0) {
    sql += '-- Indexes for Foreign Keys (Performance Optimization)\n';
    sql += '-- Foreign key columns should be indexed for optimal query performance\n\n';
    
    foreignKeyConstraints.forEach(fk => {
      sql += `CREATE INDEX idx_${fk.sourceTable}_${fk.sourceField} ON ${fk.sourceTable}(${fk.sourceField});\n`;
    });
    sql += '\n';
  }
  
  // Add relationship summary comment
  if (foreignKeyConstraints.length > 0) {
    sql += '-- Relationship Summary\n';
    sql += `-- Total tables: ${Object.keys(schema).length}\n`;
    sql += `-- Total foreign key relationships: ${foreignKeyConstraints.length}\n`;
    sql += '-- Relationships:\n';
    
    foreignKeyConstraints.forEach(fk => {
      sql += `--   ${fk.sourceTable}.${fk.sourceField} (${fk.sourceFieldType}) -> ${fk.targetTable}.${fk.targetField} (${fk.targetFieldType})\n`;
    });
    sql += '\n';
  }
  
  // Add sample data insert comments
  sql += '-- Sample INSERT statements (uncomment and modify as needed)\n';
  sql += '-- Remember to insert parent table records before child table records\n\n';
  
  // Sort tables by dependency (tables with no FK dependencies first)
  const tablesWithoutFKs = [];
  const tablesWithFKs = [];
  
  Object.entries(schema).forEach(([nodeId, table]) => {
    if (!table.tableName || !table.fields) return;
    
    const hasForeignKeys = table.fields.some(f => f.foreignKey);
    if (hasForeignKeys) {
      tablesWithFKs.push(table);
    } else {
      tablesWithoutFKs.push(table);
    }
  });
  
  // Generate sample inserts for tables without FKs first
  [...tablesWithoutFKs, ...tablesWithFKs].forEach(table => {
    const nonAutoFields = table.fields.filter(f => !f.autoIncrement);
    if (nonAutoFields.length > 0) {
      const fieldNames = nonAutoFields.map(f => f.name).join(', ');
      const placeholders = nonAutoFields.map(f => {
        if (['INT', 'BIGINT', 'DECIMAL', 'FLOAT', 'DOUBLE', 'TINYINT', 'SMALLINT', 'MEDIUMINT'].includes(f.type)) {
          return f.foreignKey ? '1 -- Reference to parent table ID' : '1';
        } else if (f.type === 'DATE') {
          return "'2024-01-01'";
        } else if (f.type === 'DATETIME' || f.type === 'TIMESTAMP') {
          return "'2024-01-01 00:00:00'";
        } else if (f.type === 'JSON') {
          return "'{\"key\": \"value\"}'";
        } else {
          return f.foreignKey ? "'parent_reference'" : "'sample_value'";
        }
      }).join(', ');
      
      sql += `-- INSERT INTO ${table.tableName} (${fieldNames}) VALUES (${placeholders});\n`;
    }
  });
  
  sql += '\n-- End of generated SQL\n';
  sql += '-- \n';
  sql += '-- Notes:\n';
  sql += '-- 1. All foreign key constraints use RESTRICT on DELETE and CASCADE on UPDATE\n';
  sql += '-- 2. Indexes are automatically created for foreign key columns\n';
  sql += '-- 3. Insert data into parent tables before child tables to avoid constraint violations\n';
  sql += '-- 4. All tables use InnoDB engine for foreign key support\n';
  
  return sql;
};